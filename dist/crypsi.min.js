var crypsi;!function(){"use strict";var n={d:function(t,r){for(var e in r)n.o(r,e)&&!n.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:r[e]})},o:function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r:function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},t={};n.r(t),n.d(t,{aes:function(){return e},digest:function(){return i},rsa:function(){return o},utils:function(){return r}});var r={};n.r(r),n.d(r,{DIGEST:function(){return S},DIGEST_SALT_LENGTH:function(){return A},arrayBufferToString:function(){return h},fromHex:function(){return s},str2ab:function(){return f},stringToArrayBuffer:function(){return y},toHex:function(){return a}});var e={};n.r(e),n.d(e,{decryptWithAes256Gcm:function(){return w},encryptWithAes256Gcm:function(){return d}});var i={};n.r(i),n.d(i,{sha1DigestHex:function(){return p},sha256DigestHex:function(){return H},sha384DigestHex:function(){return E},sha512DigestHex:function(){return P}});var o={};n.r(o),n.d(o,{decryptWithOAEPSha1:function(){return C},decryptWithOAEPSha256:function(){return U},decryptWithOAEPSha384:function(){return G},decryptWithOAEPSha512:function(){return I},encryptWithOAEPSha1:function(){return O},encryptWithOAEPSha256:function(){return T},encryptWithOAEPSha384:function(){return R},encryptWithOAEPSha512:function(){return x},signWithPssSha1:function(){return B},signWithPssSha256:function(){return k},signWithPssSha384:function(){return L},signWithPssSha512:function(){return M},verifySignatureWithPssSha1:function(){return j},verifySignatureWithPssSha256:function(){return N},verifySignatureWithPssSha384:function(){return Y},verifySignatureWithPssSha512:function(){return _}});const u="0123456789abcdef",c={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function a(n){return Array.from(n||[]).map((n=>u[n>>4]+u[15&n])).join("")}function s(n){const t=new Uint8Array(Math.floor((n||"").length/2));let r;for(r=0;r<t.length;r++){const e=c[n[2*r]],i=c[n[2*r+1]];if(void 0===e||void 0===i)break;t[r]=e<<4|i}return r===t.length?t:t.slice(0,r)}function f(n){const t=new ArrayBuffer(n.length),r=new Uint8Array(t);for(let t=0,e=n.length;t<e;t++)r[t]=n.charCodeAt(t);return t}function y(n){let t=decodeURIComponent(encodeURIComponent(n)),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function h(n){let t=new Uint8Array(n),r="";for(let n=0;n<t.byteLength;n++)r+=String.fromCharCode(t[n]);return r}const S={"SHA-1":"SHA-1","SHA-256":"SHA-256","SHA-384":"SHA-384","SHA-512":"SHA-512"},A={"SHA-1":20,"SHA-256":32,"SHA-384":48,"SHA-512":64};async function l(n){if(32!==n.length)throw new Error("invalid key length, AES 256 key length should be 32 bytes length");const t=new TextEncoder;return await crypto.subtle.importKey("raw",t.encode(n),{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function d(n,t){const r=await l(n),e=(new TextEncoder).encode(t),i=crypto.getRandomValues(new Uint8Array(12)),o={name:"AES-GCM",iv:i},u=await crypto.subtle.encrypt(o,r,e),c=new Uint8Array(u);let s=new Uint8Array(i.length+c.length);return s.set(i),s.set(c,i.length),a(s)}async function w(n,t){const r=await l(n),e={name:"AES-GCM",iv:s(t.slice(0,24))};return await crypto.subtle.decrypt(e,r,s(t.slice(24,t.length)))}async function g(n,t){const r=await crypto.subtle.digest(n,t);return new Uint8Array(r)}async function p(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),a(await g(S["SHA-1"],n))}async function H(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),a(await g(S["SHA-256"],n))}async function E(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),a(await g(S["SHA-384"],n))}async function P(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),a(await g(S["SHA-512"],n))}function b(n){const t=n.substring("-----BEGIN PUBLIC KEY-----".length,n.length-"-----END PUBLIC KEY-----\n".length);return f(window.atob(t))}function m(n){const t=n.substring("-----BEGIN PRIVATE KEY-----".length,n.length-"-----END PRIVATE KEY-----\n".length);return f(window.atob(t))}async function v(n,t,r){const e=await async function(n,t){const r=b(n);return await crypto.subtle.importKey("spki",r,{name:"RSA-OAEP",hash:t},!0,["encrypt"])}(n,t);return await window.crypto.subtle.encrypt({name:"RSA-OAEP",hash:t},e,r)}async function W(n,t,r){const e=await async function(n,t){const r=m(n);return await window.crypto.subtle.importKey("pkcs8",r,{name:"RSA-OAEP",hash:t},!0,["decrypt"])}(n,t);return await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:t},e,r)}function O(n,t){return v(n,S["SHA-1"],t)}function T(n,t){return v(n,S["SHA-256"],t)}function R(n,t){return v(n,S["SHA-384"],t)}function x(n,t){return v(n,S["SHA-512"],t)}function C(n,t){return W(n,S["SHA-1"],t)}function U(n,t){return W(n,S["SHA-256"],t)}function G(n,t){return W(n,S["SHA-384"],t)}function I(n,t){return W(n,S["SHA-512"],t)}async function D(n,t,r){const e=await async function(n,t){const r=m(n);return await window.crypto.subtle.importKey("pkcs8",r,{name:"RSA-PSS",hash:t},!0,["sign"])}(n,t);return await window.crypto.subtle.sign({name:"RSA-PSS",saltLength:A[t]},e,r)}async function K(n,t,r,e){const i=await async function(n,t){const r=b(n);return await crypto.subtle.importKey("spki",r,{name:"RSA-PSS",hash:t},!0,["verify"])}(n,r);return await window.crypto.subtle.verify({name:"RSA-PSS",saltLength:A[r]},i,t,e)}function B(n,t){return D(n,S["SHA-1"],t)}function k(n,t){return D(n,S["SHA-256"],t)}function L(n,t){return D(n,S["SHA-384"],t)}function M(n,t){return D(n,S["SHA-512"],t)}function j(n,t,r){return K(n,t,S["SHA-1"],r)}function N(n,t,r){return K(n,t,S["SHA-256"],r)}function Y(n,t,r){return K(n,t,S["SHA-384"],r)}function _(n,t,r){return K(n,t,S["SHA-512"],r)}crypsi=t}();
//# sourceMappingURL=crypsi.min.js.map