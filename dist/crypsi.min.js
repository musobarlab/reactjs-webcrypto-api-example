var crypsi;!function(){"use strict";var n={d:function(t,e){for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},o:function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r:function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},t={};n.r(t),n.d(t,{aes:function(){return r},digest:function(){return i},hmac:function(){return c},rsa:function(){return o},utils:function(){return e}});var e={};n.r(e),n.d(e,{DIGEST:function(){return S},DIGEST_SALT_LENGTH:function(){return p},arrayBufferToString:function(){return A},fromHex:function(){return f},str2ab:function(){return y},stringToArrayBuffer:function(){return h},toHex:function(){return s}});var r={};n.r(r),n.d(r,{decryptWithAes128Cbc:function(){return W},decryptWithAes128Gcm:function(){return T},decryptWithAes192Cbc:function(){return v},decryptWithAes192Gcm:function(){return R},decryptWithAes256Cbc:function(){return B},decryptWithAes256Gcm:function(){return U},encryptWithAes128Cbc:function(){return E},encryptWithAes128Gcm:function(){return x},encryptWithAes192Cbc:function(){return P},encryptWithAes192Gcm:function(){return M},encryptWithAes256Cbc:function(){return G},encryptWithAes256Gcm:function(){return O}});var i={};n.r(i),n.d(i,{sha1DigestHex:function(){return D},sha256DigestHex:function(){return I},sha384DigestHex:function(){return K},sha512DigestHex:function(){return j}});var c={};n.r(c),n.d(c,{sha1HmacHex:function(){return N},sha256HmacHex:function(){return V},sha384HmacHex:function(){return Y},sha512HmacHex:function(){return _}});var o={};n.r(o),n.d(o,{decryptWithOAEPSha1:function(){return nn},decryptWithOAEPSha256:function(){return tn},decryptWithOAEPSha384:function(){return en},decryptWithOAEPSha512:function(){return rn},encryptWithOAEPSha1:function(){return J},encryptWithOAEPSha256:function(){return Q},encryptWithOAEPSha384:function(){return X},encryptWithOAEPSha512:function(){return Z},signWithPssSha1:function(){return un},signWithPssSha256:function(){return an},signWithPssSha384:function(){return sn},signWithPssSha512:function(){return fn},verifySignatureWithPssSha1:function(){return yn},verifySignatureWithPssSha256:function(){return hn},verifySignatureWithPssSha384:function(){return An},verifySignatureWithPssSha512:function(){return Sn}});const u="0123456789abcdef",a={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function s(n){return Array.from(n||[]).map((n=>u[n>>4]+u[15&n])).join("")}function f(n){const t=new Uint8Array(Math.floor((n||"").length/2));let e;for(e=0;e<t.length;e++){const r=a[n[2*e]],i=a[n[2*e+1]];if(void 0===r||void 0===i)break;t[e]=r<<4|i}return e===t.length?t:t.slice(0,e)}function y(n){const t=new ArrayBuffer(n.length),e=new Uint8Array(t);for(let t=0,r=n.length;t<r;t++)e[t]=n.charCodeAt(t);return t}function h(n){let t=decodeURIComponent(encodeURIComponent(n)),e=new Uint8Array(t.length);for(let n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e}function A(n){let t=new Uint8Array(n),e="";for(let n=0;n<t.byteLength;n++)e+=String.fromCharCode(t[n]);return e}const S={"SHA-1":"SHA-1","SHA-256":"SHA-256","SHA-384":"SHA-384","SHA-512":"SHA-512"},p={"SHA-1":20,"SHA-256":32,"SHA-384":48,"SHA-512":64},l={128:16,192:24,256:32},d={16:128,24:192,32:256},w={GCM:"AES-GCM",CBC:"AES-CBC"},g={GCM:crypto.getRandomValues(new Uint8Array(12)),CBC:crypto.getRandomValues(new Uint8Array(16))};function C(n,t,e){if(!Object.prototype.hasOwnProperty.call(d,t.length))throw new Error("invalid key AES key length, key length should be 16, 24 or 32 bytes");if(t.length!==l[e])throw new Error(`invalid key length, AES ${e} key length should be ${l[e]} bytes length`);if(!Object.prototype.hasOwnProperty.call(w,n))throw new Error(`invalid mode, mode ${n} does not exist`)}async function H(n,t){const e=new TextEncoder;return await crypto.subtle.importKey("raw",e.encode(n),{name:w[t],length:d[n.length]},!0,["encrypt","decrypt"])}async function b(n,t,e){const r=await H(n,t),i=(new TextEncoder).encode(e),c=g[t],o={name:w[t],iv:c},u=await crypto.subtle.encrypt(o,r,i),a=new Uint8Array(u);let f=new Uint8Array(c.length+a.length);return f.set(c),f.set(a,c.length),s(f)}async function m(n,t,e){const r=await H(n,t),i=function(n,t){const e={GCM:f(n.slice(0,24)),CBC:f(n.slice(0,32))},r={GCM:f(n.slice(24,n.length)),CBC:f(n.slice(32,n.length))};return{iv:e[t],cipherData:r[t]}}(e,t),c={name:w[t],iv:i.iv};return await crypto.subtle.decrypt(c,r,i.cipherData)}function E(n,t){return C("CBC",n,128),b(n,"CBC",t)}function P(n,t){return C("CBC",n,192),b(n,"CBC",t)}function G(n,t){return C("CBC",n,256),b(n,"CBC",t)}function W(n,t){return C("CBC",n,128),m(n,"CBC",t)}function v(n,t){return C("CBC",n,192),m(n,"CBC",t)}function B(n,t){return C("CBC",n,256),m(n,"CBC",t)}function x(n,t){return C("GCM",n,128),b(n,"GCM",t)}function M(n,t){return C("GCM",n,192),b(n,"GCM",t)}function O(n,t){return C("GCM",n,256),b(n,"GCM",t)}function T(n,t){return C("GCM",n,128),m(n,"GCM",t)}function R(n,t){return C("GCM",n,192),m(n,"GCM",t)}function U(n,t){return C("GCM",n,256),m(n,"GCM",t)}async function k(n,t){const e=await crypto.subtle.digest(n,t);return new Uint8Array(e)}async function D(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await k(S["SHA-1"],n))}async function I(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await k(S["SHA-256"],n))}async function K(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await k(S["SHA-384"],n))}async function j(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await k(S["SHA-512"],n))}async function L(n,t,e){const r=await async function(n,t){if(n.length<32)throw new Error("min key length must be 32 bytes length");const e=new TextEncoder;return await crypto.subtle.importKey("raw",e.encode(n),{name:"HMAC",hash:t},!1,["sign","verify"])}(n,t),i=await crypto.subtle.sign("HMAC",r,e);return new Uint8Array(i)}async function N(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await L(n,S["SHA-1"],t))}async function V(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await L(n,S["SHA-256"],t))}async function Y(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await L(n,S["SHA-384"],t))}async function _(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await L(n,S["SHA-512"],t))}function $(n){const t=n.substring("-----BEGIN PUBLIC KEY-----".length,n.length-"-----END PUBLIC KEY-----\n".length);return y(window.atob(t))}function F(n){const t=n.substring("-----BEGIN PRIVATE KEY-----".length,n.length-"-----END PRIVATE KEY-----\n".length);return y(window.atob(t))}async function q(n,t,e){const r=await async function(n,t){const e=$(n);return await crypto.subtle.importKey("spki",e,{name:"RSA-OAEP",hash:t},!0,["encrypt"])}(n,t);return await window.crypto.subtle.encrypt({name:"RSA-OAEP",hash:t},r,e)}async function z(n,t,e){const r=await async function(n,t){const e=F(n);return await window.crypto.subtle.importKey("pkcs8",e,{name:"RSA-OAEP",hash:t},!0,["decrypt"])}(n,t);return await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:t},r,e)}function J(n,t){return q(n,S["SHA-1"],t)}function Q(n,t){return q(n,S["SHA-256"],t)}function X(n,t){return q(n,S["SHA-384"],t)}function Z(n,t){return q(n,S["SHA-512"],t)}function nn(n,t){return z(n,S["SHA-1"],t)}function tn(n,t){return z(n,S["SHA-256"],t)}function en(n,t){return z(n,S["SHA-384"],t)}function rn(n,t){return z(n,S["SHA-512"],t)}async function cn(n,t,e){const r=await async function(n,t){const e=F(n);return await window.crypto.subtle.importKey("pkcs8",e,{name:"RSA-PSS",hash:t},!0,["sign"])}(n,t);return await window.crypto.subtle.sign({name:"RSA-PSS",saltLength:p[t]},r,e)}async function on(n,t,e,r){const i=await async function(n,t){const e=$(n);return await crypto.subtle.importKey("spki",e,{name:"RSA-PSS",hash:t},!0,["verify"])}(n,e);return await window.crypto.subtle.verify({name:"RSA-PSS",saltLength:p[e]},i,t,r)}function un(n,t){return cn(n,S["SHA-1"],t)}function an(n,t){return cn(n,S["SHA-256"],t)}function sn(n,t){return cn(n,S["SHA-384"],t)}function fn(n,t){return cn(n,S["SHA-512"],t)}function yn(n,t,e){return on(n,t,S["SHA-1"],e)}function hn(n,t,e){return on(n,t,S["SHA-256"],e)}function An(n,t,e){return on(n,t,S["SHA-384"],e)}function Sn(n,t,e){return on(n,t,S["SHA-512"],e)}crypsi=t}();
//# sourceMappingURL=crypsi.min.js.map