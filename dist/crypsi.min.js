var crypsi;!function(){"use strict";var n={d:function(t,e){for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},o:function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r:function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},t={};n.r(t),n.d(t,{aes:function(){return r},digest:function(){return i},hmac:function(){return o},rsa:function(){return c},utils:function(){return e}});var e={};n.r(e),n.d(e,{DIGEST:function(){return A},DIGEST_SALT_LENGTH:function(){return w},arrayBufferToString:function(){return S},fromHex:function(){return f},str2ab:function(){return y},stringToArrayBuffer:function(){return h},toHex:function(){return s}});var r={};n.r(r),n.d(r,{decryptWithAes256Gcm:function(){return g},encryptWithAes256Gcm:function(){return l}});var i={};n.r(i),n.d(i,{sha1DigestHex:function(){return H},sha256DigestHex:function(){return E},sha384DigestHex:function(){return m},sha512DigestHex:function(){return b}});var o={};n.r(o),n.d(o,{sha1HmacHex:function(){return v},sha256HmacHex:function(){return x},sha384HmacHex:function(){return T},sha512HmacHex:function(){return W}});var c={};n.r(c),n.d(c,{decryptWithOAEPSha1:function(){return k},decryptWithOAEPSha256:function(){return B},decryptWithOAEPSha384:function(){return M},decryptWithOAEPSha512:function(){return L},encryptWithOAEPSha1:function(){return G},encryptWithOAEPSha256:function(){return I},encryptWithOAEPSha384:function(){return K},encryptWithOAEPSha512:function(){return D},signWithPssSha1:function(){return Y},signWithPssSha256:function(){return _},signWithPssSha384:function(){return V},signWithPssSha512:function(){return F},verifySignatureWithPssSha1:function(){return q},verifySignatureWithPssSha256:function(){return z},verifySignatureWithPssSha384:function(){return J},verifySignatureWithPssSha512:function(){return Q}});const u="0123456789abcdef",a={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function s(n){return Array.from(n||[]).map((n=>u[n>>4]+u[15&n])).join("")}function f(n){const t=new Uint8Array(Math.floor((n||"").length/2));let e;for(e=0;e<t.length;e++){const r=a[n[2*e]],i=a[n[2*e+1]];if(void 0===r||void 0===i)break;t[e]=r<<4|i}return e===t.length?t:t.slice(0,e)}function y(n){const t=new ArrayBuffer(n.length),e=new Uint8Array(t);for(let t=0,r=n.length;t<r;t++)e[t]=n.charCodeAt(t);return t}function h(n){let t=decodeURIComponent(encodeURIComponent(n)),e=new Uint8Array(t.length);for(let n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e}function S(n){let t=new Uint8Array(n),e="";for(let n=0;n<t.byteLength;n++)e+=String.fromCharCode(t[n]);return e}const A={"SHA-1":"SHA-1","SHA-256":"SHA-256","SHA-384":"SHA-384","SHA-512":"SHA-512"},w={"SHA-1":20,"SHA-256":32,"SHA-384":48,"SHA-512":64};async function d(n){if(32!==n.length)throw new Error("invalid key length, AES 256 key length should be 32 bytes length");const t=new TextEncoder;return await crypto.subtle.importKey("raw",t.encode(n),{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function l(n,t){const e=await d(n),r=(new TextEncoder).encode(t),i=crypto.getRandomValues(new Uint8Array(12)),o={name:"AES-GCM",iv:i},c=await crypto.subtle.encrypt(o,e,r),u=new Uint8Array(c);let a=new Uint8Array(i.length+u.length);return a.set(i),a.set(u,i.length),s(a)}async function g(n,t){const e=await d(n),r={name:"AES-GCM",iv:f(t.slice(0,24))};return await crypto.subtle.decrypt(r,e,f(t.slice(24,t.length)))}async function p(n,t){const e=await crypto.subtle.digest(n,t);return new Uint8Array(e)}async function H(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await p(A["SHA-1"],n))}async function E(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await p(A["SHA-256"],n))}async function m(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await p(A["SHA-384"],n))}async function b(n){return"string"==typeof n&&(n=(new TextEncoder).encode(n)),s(await p(A["SHA-512"],n))}async function P(n,t,e){const r=await async function(n,t){if(n.length<32)throw new Error("min key length must be 32 bytes length");const e=new TextEncoder;return await crypto.subtle.importKey("raw",e.encode(n),{name:"HMAC",hash:t},!1,["sign","verify"])}(n,t),i=await crypto.subtle.sign("HMAC",r,e);return new Uint8Array(i)}async function v(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await P(n,A["SHA-1"],t))}async function x(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await P(n,A["SHA-256"],t))}async function T(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await P(n,A["SHA-384"],t))}async function W(n,t){return"string"==typeof t&&(t=(new TextEncoder).encode(t)),s(await P(n,A["SHA-512"],t))}function O(n){const t=n.substring("-----BEGIN PUBLIC KEY-----".length,n.length-"-----END PUBLIC KEY-----\n".length);return y(window.atob(t))}function C(n){const t=n.substring("-----BEGIN PRIVATE KEY-----".length,n.length-"-----END PRIVATE KEY-----\n".length);return y(window.atob(t))}async function R(n,t,e){const r=await async function(n,t){const e=O(n);return await crypto.subtle.importKey("spki",e,{name:"RSA-OAEP",hash:t},!0,["encrypt"])}(n,t);return await window.crypto.subtle.encrypt({name:"RSA-OAEP",hash:t},r,e)}async function U(n,t,e){const r=await async function(n,t){const e=C(n);return await window.crypto.subtle.importKey("pkcs8",e,{name:"RSA-OAEP",hash:t},!0,["decrypt"])}(n,t);return await window.crypto.subtle.decrypt({name:"RSA-OAEP",hash:t},r,e)}function G(n,t){return R(n,A["SHA-1"],t)}function I(n,t){return R(n,A["SHA-256"],t)}function K(n,t){return R(n,A["SHA-384"],t)}function D(n,t){return R(n,A["SHA-512"],t)}function k(n,t){return U(n,A["SHA-1"],t)}function B(n,t){return U(n,A["SHA-256"],t)}function M(n,t){return U(n,A["SHA-384"],t)}function L(n,t){return U(n,A["SHA-512"],t)}async function j(n,t,e){const r=await async function(n,t){const e=C(n);return await window.crypto.subtle.importKey("pkcs8",e,{name:"RSA-PSS",hash:t},!0,["sign"])}(n,t);return await window.crypto.subtle.sign({name:"RSA-PSS",saltLength:w[t]},r,e)}async function N(n,t,e,r){const i=await async function(n,t){const e=O(n);return await crypto.subtle.importKey("spki",e,{name:"RSA-PSS",hash:t},!0,["verify"])}(n,e);return await window.crypto.subtle.verify({name:"RSA-PSS",saltLength:w[e]},i,t,r)}function Y(n,t){return j(n,A["SHA-1"],t)}function _(n,t){return j(n,A["SHA-256"],t)}function V(n,t){return j(n,A["SHA-384"],t)}function F(n,t){return j(n,A["SHA-512"],t)}function q(n,t,e){return N(n,t,A["SHA-1"],e)}function z(n,t,e){return N(n,t,A["SHA-256"],e)}function J(n,t,e){return N(n,t,A["SHA-384"],e)}function Q(n,t,e){return N(n,t,A["SHA-512"],e)}crypsi=t}();
//# sourceMappingURL=crypsi.min.js.map