{"version":3,"file":"crypsi.min.js","mappings":"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","sources":["webpack://crypsi/webpack/bootstrap","webpack://crypsi/webpack/runtime/define property getters","webpack://crypsi/webpack/runtime/hasOwnProperty shorthand","webpack://crypsi/webpack/runtime/make namespace object","webpack://crypsi/./src/crypsi/utils.js","webpack://crypsi/./src/crypsi/aes.js","webpack://crypsi/./src/crypsi/digest.js","webpack://crypsi/./src/crypsi/hmac.js","webpack://crypsi/./src/crypsi/rsa.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const HEX_STRINGS = \"0123456789abcdef\";\nconst MAP_HEX = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6,\n    7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13,\n    e: 14, f: 15, A: 10, B: 11, C: 12, D: 13,\n    E: 14, F: 15\n};\n\nexport function toHex(bytes) {\n    return Array.from(bytes || [])\n        .map((b) => HEX_STRINGS[b >> 4] + HEX_STRINGS[b & 15])\n        .join(\"\");\n}\n\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const bytes = new Uint8Array(Math.floor((hexString || \"\").length / 2));\n    let i;\n    for (i = 0; i < bytes.length; i++) {\n        const a = MAP_HEX[hexString[i * 2]];\n        const b = MAP_HEX[hexString[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n\n        bytes[i] = (a << 4) | b;\n    }\n\n    return i === bytes.length ? bytes : bytes.slice(0, i);\n}\n\n// Convert a string into an ArrayBuffer\nexport function str2ab(str) {\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n\nexport function stringToArrayBuffer(data) {\n    let buf = decodeURIComponent(encodeURIComponent(data)) // 2 bytes for each char\n    let arrayBuf = new Uint8Array(buf.length)\n    for (let i=0; i < buf.length; i++) {\n        arrayBuf[i] = buf.charCodeAt(i)\n    }\n    return arrayBuf\n}\n\nexport function arrayBufferToString(arrayBuffer) {\n    let byteArray = new Uint8Array(arrayBuffer)\n    let str = ''\n    for (let i=0; i<byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return str\n}\n\nexport const DIGEST = {\n    'SHA-1': 'SHA-1',\n    'SHA-256': 'SHA-256',\n    'SHA-384': 'SHA-384',\n    'SHA-512': 'SHA-512'\n};\n\nexport const DIGEST_SALT_LENGTH = {\n    'SHA-1': 20,\n    'SHA-256': 32,\n    'SHA-384': 48,\n    'SHA-512': 64\n};","import { fromHex, toHex } from './utils';\n\nconst KEY_BYTE_SIZE = {\n    128: 16,\n    192: 24,\n    256: 32\n};\n\nconst KEY_BIT_SIZE = {\n    16: 128,\n    24: 192,\n    32: 256\n};\n\nconst MODES = {\n    'GCM': 'AES-GCM',\n    'CBC': 'AES-CBC'\n};\n\nconst IVS = {\n    'GCM': crypto.getRandomValues(new Uint8Array(12)),\n    'CBC': crypto.getRandomValues(new Uint8Array(16))\n};\n\nfunction validateKeyAndMode(mode, rawKey, bitSize) {\n    if (!Object.prototype.hasOwnProperty.call(KEY_BIT_SIZE, rawKey.length)) {\n        throw new Error(`invalid key AES key length, key length should be 16, 24 or 32 bytes`);\n    }\n\n    if (rawKey.length !== KEY_BYTE_SIZE[bitSize]) {\n        throw new Error(`invalid key length, AES ${bitSize} key length should be ${KEY_BYTE_SIZE[bitSize]} bytes length`);\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(MODES, mode)) {\n        throw new Error(`invalid mode, mode ${mode} does not exist`);\n    }\n}\n\nasync function importKey(rawKey, mode) {\n    const encoder = new TextEncoder();\n    return await crypto.subtle.importKey(\n        \"raw\", \n        encoder.encode(rawKey), \n        {\n            name: MODES[mode], \n            length: KEY_BIT_SIZE[rawKey.length],\n        }, \n        true, \n        ['encrypt', 'decrypt'],\n    );\n}\n\nfunction parseEncryptedData(encryptedData, mode) {\n    const ivs = {\n        'GCM': fromHex(encryptedData.slice(0, 24)),\n        'CBC': fromHex(encryptedData.slice(0, 32))\n    };\n\n    const cipherDatas = {\n        'GCM': fromHex(encryptedData.slice(24, encryptedData.length)),\n        'CBC': fromHex(encryptedData.slice(32, encryptedData.length))\n    }\n\n    return {iv: ivs[mode], cipherData: cipherDatas[mode]}\n}\n\nasync function encrypt(key, mode, data) {\n    const importedKey = await importKey(key, mode);\n\n    const encoder = new TextEncoder();\n    const encoded = encoder.encode(data);\n  \n    // The iv must never be reused with a given key.\n    const iv = IVS[mode];\n    const alg = {\n        name: MODES[mode],\n        iv: iv,\n    };\n\n    const cipherData = await crypto.subtle.encrypt(\n        alg,\n        importedKey,\n        encoded,\n    );\n\n    const cipherDataBuf = new Uint8Array(cipherData);\n    \n    let allBuf = new Uint8Array(iv.length+cipherDataBuf.length);\n    allBuf.set(iv);\n    allBuf.set(cipherDataBuf, iv.length);\n    return toHex(allBuf);\n}\n\nasync function decrypt(key, mode, encryptedData) {\n    const importedKey = await importKey(key, mode);\n\n    const parsedEncryptedData = parseEncryptedData(encryptedData, mode);\n    const alg = {\n        name: MODES[mode],\n        iv: parsedEncryptedData.iv,\n    };\n\n    return await crypto.subtle.decrypt(\n        alg, \n        importedKey, \n        parsedEncryptedData.cipherData,\n    );\n}\n\n// CBC Encrypt\nexport function encryptWithAes128Cbc(key, data) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 128);\n    return encrypt(key, mode, data);\n}\n\n// not yet supported\nexport function encryptWithAes192Cbc(key, data) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 192);\n    return encrypt(key, mode, data);\n}\n\nexport function encryptWithAes256Cbc(key, data) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 256);\n    return encrypt(key, mode, data);\n}\n\n// CBC Decrypt\nexport function decryptWithAes128Cbc(key, encryptedData) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 128);\n    return decrypt(key, mode, encryptedData);\n}\n\n// not yet supported\nexport function decryptWithAes192Cbc(key, encryptedData) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 192);\n    return decrypt(key, mode, encryptedData);\n}\n\nexport function decryptWithAes256Cbc(key, encryptedData) {\n    const mode = 'CBC';\n    validateKeyAndMode(mode, key, 256);\n    return decrypt(key, mode, encryptedData);\n}\n\n// GCM Encrypt\nexport function encryptWithAes128Gcm(key, data) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 128);\n    return encrypt(key, mode, data);\n}\n\n// not yet supported\nexport function encryptWithAes192Gcm(key, data) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 192);\n    return encrypt(key, mode, data);\n}\n\nexport function encryptWithAes256Gcm(key, data) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 256);\n    return encrypt(key, mode, data);\n}\n\n// GCM Decrypt\nexport function decryptWithAes128Gcm(key, encryptedData) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 128);\n    return decrypt(key, mode, encryptedData);\n}\n\n// not yet supported\nexport function decryptWithAes192Gcm(key, encryptedData) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 192);\n    return decrypt(key, mode, encryptedData);\n}\n\nexport function decryptWithAes256Gcm(key, encryptedData) {\n    const mode = 'GCM';\n    validateKeyAndMode(mode, key, 256);\n    return decrypt(key, mode, encryptedData);\n}","import { DIGEST, toHex } from './utils';\n\nasync function digest(alg, data) {\n    const hash = await crypto.subtle.digest(alg, data);\n    return new Uint8Array(hash);\n}\n\nexport async function sha1DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-1'], data);\n    return toHex(buf);\n}\n\nexport async function sha256DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-256'], data);\n    return toHex(buf);\n}\n\nexport async function sha384DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-384'], data);\n    return toHex(buf);\n}\n\nexport async function sha512DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-512'], data);\n    return toHex(buf);\n}","import { DIGEST, toHex } from './utils';\n\nconst HMAC_MIN_KEY_SIZE = 32;\n\nasync function importKey(rawKey, hashAlg) {\n    if (rawKey.length < HMAC_MIN_KEY_SIZE) {\n        throw new Error(`min key length must be ${HMAC_MIN_KEY_SIZE} bytes length`);\n    }\n\n    const encoder = new TextEncoder();\n    return await crypto.subtle.importKey(\n        \"raw\", \n        encoder.encode(rawKey), \n        {\n            name: \"HMAC\", \n            hash: hashAlg,\n        }, \n        false, \n        ['sign', 'verify'],\n    );\n}\n\nasync function mac(key, hashAlg, data) {\n    const importedKey = await importKey(key, hashAlg);\n\n    const signature = await crypto.subtle.sign('HMAC', importedKey, data);\n    return new Uint8Array(signature);\n}\n\nexport async function sha1HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-1'], data);\n    return toHex(buf);\n}\n\nexport async function sha256HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-256'], data);\n    return toHex(buf);\n}\n\nexport async function sha384HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-384'], data);\n    return toHex(buf);\n}\n\nexport async function sha512HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-512'], data);\n    return toHex(buf);\n}","import { fromHex, toHex, str2ab, DIGEST, DIGEST_SALT_LENGTH } from './utils';\n\nfunction loadPublicKey(pem) {\n    const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n    const pemFooter = \"-----END PUBLIC KEY-----\\n\";\n    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);\n    // base64 decode the string to get the binary data\n    const binaryDerString = window.atob(pemContents);\n    // convert from a binary string to an ArrayBuffer\n    const binaryDer = str2ab(binaryDerString);\n    return binaryDer;\n}\n\nfunction loadPrivateKey(pem) {\n    // fetch the part of the PEM string between header and footer\n    const pemHeader = \"-----BEGIN PRIVATE KEY-----\";\n    const pemFooter = \"-----END PRIVATE KEY-----\\n\";\n    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);\n    // base64 decode the string to get the binary data\n    const binaryDerString = window.atob(pemContents);\n    // convert from a binary string to an ArrayBuffer\n    const binaryDer = str2ab(binaryDerString);\n    return binaryDer;\n}\n\nasync function loadPublicKeyForEncryption(pem, alg) {\n    const binaryDer = loadPublicKey(pem);\n\n    return await crypto.subtle.importKey(\n        'spki', \n        binaryDer, \n        {\n            name: 'RSA-OAEP',\n            hash: alg,\n        }, \n        true, \n        ['encrypt']\n    );\n}\n\nasync function loadPublicKeyForVerifySignature(pem, alg) {\n    const binaryDer = loadPublicKey(pem);\n\n    return await crypto.subtle.importKey(\n        'spki', \n        binaryDer, \n        {\n            name: 'RSA-PSS',\n            hash: alg,\n        }, \n        true, \n        ['verify']\n    );\n}\n\n//  format should be PKCS8\nasync function loadPrivateKeyForEncryption(pem, alg) {\n    const binaryDer = loadPrivateKey(pem)\n\n    return await window.crypto.subtle.importKey(\n        'pkcs8',\n        binaryDer,\n        {\n            name: 'RSA-OAEP',\n            hash: alg,\n        },\n        true,\n        ['decrypt']  \n    );\n}\n\n//  format should be PKCS8\nasync function loadPrivateKeyForSigning(pem, alg) {\n    const binaryDer = loadPrivateKey(pem)\n\n    return await window.crypto.subtle.importKey(\n        'pkcs8',\n        binaryDer,\n        {\n            name: 'RSA-PSS',\n            hash: alg,\n        },\n        true,\n        ['sign']  \n    );\n}\n\nasync function encryptWithOAEP(publicKey, hash, plainData) {\n    const key = await loadPublicKeyForEncryption(publicKey, hash);\n    return await window.crypto.subtle.encrypt(\n        {\n            name: 'RSA-OAEP',\n            hash: hash,\n        },\n        key,\n        plainData,\n    );\n}\n\nasync function decryptWithOAEP(privateKey, hash, encryptedData) {\n    const key = await loadPrivateKeyForEncryption(privateKey, hash);\n    return await window.crypto.subtle.decrypt(\n        {\n            name: 'RSA-OAEP',\n            hash: hash,\n        },\n        key,\n        encryptedData,\n    );\n}\n\n// encryption\nexport function encryptWithOAEPSha1(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-1'], plainData);\n}\n\nexport function encryptWithOAEPSha256(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-256'], plainData);\n}\n\nexport function encryptWithOAEPSha384(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-384'], plainData);\n}\n\nexport function encryptWithOAEPSha512(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-512'], plainData);\n}\n\n// decryption\nexport function decryptWithOAEPSha1(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-1'], encryptedData);\n}\n\nexport function decryptWithOAEPSha256(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-256'], encryptedData);\n}\n\nexport function decryptWithOAEPSha384(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-384'], encryptedData);\n}\n\nexport function decryptWithOAEPSha512(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-512'], encryptedData);\n}\n\n// digital signature\n\n// sign data with PSS and return a promise a promise that fulfills an array buffer containing the signature\nasync function signWithPss(privateKey, hash, data) {\n    const key = await loadPrivateKeyForSigning(privateKey, hash);\n    return await window.crypto.subtle.sign(\n        {\n            name: 'RSA-PSS',\n            saltLength: DIGEST_SALT_LENGTH[hash]\n        },\n        key,\n        data,\n    );\n}\n\n// verify signature with PSS and return a Promise that fulfills with a boolean value: true if the signature is valid, false otherwise.\nasync function verifySignatureWithPss(publicKey, signature, hash, data) {\n    const key = await loadPublicKeyForVerifySignature(publicKey, hash);\n    return await window.crypto.subtle.verify(\n        {\n            name: 'RSA-PSS',\n            saltLength: DIGEST_SALT_LENGTH[hash]\n        },\n        key,\n        signature,\n        data,\n    );\n}\n\nexport function signWithPssSha1(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-1'], data);\n}\n\nexport function signWithPssSha256(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-256'], data);\n}\n\nexport function signWithPssSha384(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-384'], data);\n}\n\nexport function signWithPssSha512(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-512'], data);\n}\n\nexport function verifySignatureWithPssSha1(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-1'], data);\n}\n\nexport function verifySignatureWithPssSha256(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-256'], data);\n}\n\nexport function verifySignatureWithPssSha384(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-384'], data);\n}\n\nexport function verifySignatureWithPssSha512(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-512'], data);\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","HEX_STRINGS","MAP_HEX","a","b","c","d","e","f","A","B","C","D","E","F","toHex","bytes","Array","from","map","join","fromHex","hexString","Uint8Array","Math","floor","length","i","undefined","slice","str2ab","str","buf","ArrayBuffer","bufView","strLen","charCodeAt","stringToArrayBuffer","data","decodeURIComponent","encodeURIComponent","arrayBuf","arrayBufferToString","arrayBuffer","byteArray","byteLength","String","fromCharCode","DIGEST","DIGEST_SALT_LENGTH","KEY_BYTE_SIZE","KEY_BIT_SIZE","MODES","IVS","crypto","getRandomValues","validateKeyAndMode","mode","rawKey","bitSize","Error","async","importKey","encoder","TextEncoder","subtle","encode","name","encrypt","importedKey","encoded","iv","alg","cipherData","cipherDataBuf","allBuf","set","decrypt","encryptedData","parsedEncryptedData","ivs","cipherDatas","parseEncryptedData","encryptWithAes128Cbc","encryptWithAes192Cbc","encryptWithAes256Cbc","decryptWithAes128Cbc","decryptWithAes192Cbc","decryptWithAes256Cbc","encryptWithAes128Gcm","encryptWithAes192Gcm","encryptWithAes256Gcm","decryptWithAes128Gcm","decryptWithAes192Gcm","decryptWithAes256Gcm","digest","hash","sha1DigestHex","sha256DigestHex","sha384DigestHex","sha512DigestHex","mac","hashAlg","signature","sign","sha1HmacHex","sha256HmacHex","sha384HmacHex","sha512HmacHex","loadPublicKey","pem","pemContents","substring","window","atob","loadPrivateKey","encryptWithOAEP","publicKey","plainData","binaryDer","loadPublicKeyForEncryption","decryptWithOAEP","privateKey","loadPrivateKeyForEncryption","encryptWithOAEPSha1","encryptWithOAEPSha256","encryptWithOAEPSha384","encryptWithOAEPSha512","decryptWithOAEPSha1","decryptWithOAEPSha256","decryptWithOAEPSha384","decryptWithOAEPSha512","signWithPss","loadPrivateKeyForSigning","saltLength","verifySignatureWithPss","loadPublicKeyForVerifySignature","verify","signWithPssSha1","signWithPssSha256","signWithPssSha384","signWithPssSha512","verifySignatureWithPssSha1","verifySignatureWithPssSha256","verifySignatureWithPssSha384","verifySignatureWithPssSha512"],"sourceRoot":""}