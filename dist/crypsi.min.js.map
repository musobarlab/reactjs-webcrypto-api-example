{"version":3,"file":"crypsi.min.js","mappings":"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","sources":["webpack://crypsi/webpack/bootstrap","webpack://crypsi/webpack/runtime/define property getters","webpack://crypsi/webpack/runtime/hasOwnProperty shorthand","webpack://crypsi/webpack/runtime/make namespace object","webpack://crypsi/./src/crypsi/utils.js","webpack://crypsi/./src/crypsi/aes.js","webpack://crypsi/./src/crypsi/digest.js","webpack://crypsi/./src/crypsi/hmac.js","webpack://crypsi/./src/crypsi/rsa.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const HEX_STRINGS = \"0123456789abcdef\";\nconst MAP_HEX = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6,\n    7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13,\n    e: 14, f: 15, A: 10, B: 11, C: 12, D: 13,\n    E: 14, F: 15\n};\n\nexport function toHex(bytes) {\n    return Array.from(bytes || [])\n        .map((b) => HEX_STRINGS[b >> 4] + HEX_STRINGS[b & 15])\n        .join(\"\");\n}\n\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const bytes = new Uint8Array(Math.floor((hexString || \"\").length / 2));\n    let i;\n    for (i = 0; i < bytes.length; i++) {\n        const a = MAP_HEX[hexString[i * 2]];\n        const b = MAP_HEX[hexString[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n\n        bytes[i] = (a << 4) | b;\n    }\n\n    return i === bytes.length ? bytes : bytes.slice(0, i);\n}\n\n// Convert a string into an ArrayBuffer\nexport function str2ab(str) {\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n\nexport function stringToArrayBuffer(data) {\n    let buf = decodeURIComponent(encodeURIComponent(data)) // 2 bytes for each char\n    let arrayBuf = new Uint8Array(buf.length)\n    for (let i=0; i < buf.length; i++) {\n        arrayBuf[i] = buf.charCodeAt(i)\n    }\n    return arrayBuf\n}\n\nexport function arrayBufferToString(arrayBuffer) {\n    let byteArray = new Uint8Array(arrayBuffer)\n    let str = ''\n    for (let i=0; i<byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return str\n}\n\nexport const DIGEST = {\n    'SHA-1': 'SHA-1',\n    'SHA-256': 'SHA-256',\n    'SHA-384': 'SHA-384',\n    'SHA-512': 'SHA-512'\n};\n\nexport const DIGEST_SALT_LENGTH = {\n    'SHA-1': 20,\n    'SHA-256': 32,\n    'SHA-384': 48,\n    'SHA-512': 64\n};","\nimport { fromHex, toHex } from './utils';\n\nconst AES_128_KEY_SIZE = 16;\nconst AES_192_KEY_SIZE = 24;\nconst AES_256_KEY_SIZE = 32;\n\nasync function importKeyAES256(rawKey) {\n    if (rawKey.length !== AES_256_KEY_SIZE) {\n        throw new Error(`invalid key length, AES 256 key length should be ${AES_256_KEY_SIZE} bytes length`);\n    }\n\n    const encoder = new TextEncoder();\n    return await crypto.subtle.importKey(\n        \"raw\", \n        encoder.encode(rawKey), \n        {\n            name: \"AES-GCM\", \n            length: 256,\n        }, \n        true, \n        ['encrypt', 'decrypt'],\n    );\n}\n\nexport async function encryptWithAes256Gcm(key, data) {\n    const importedKey = await importKeyAES256(key);\n\n    const encoder = new TextEncoder();\n    const encoded = encoder.encode(data);\n  \n    // The iv must never be reused with a given key.\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const alg = {\n        name: \"AES-GCM\",\n        iv: iv,\n    };\n\n    const cipherData = await crypto.subtle.encrypt(\n        alg,\n        importedKey,\n        encoded,\n    );\n\n    const cipherDataBuf = new Uint8Array(cipherData);\n    \n    let allBuf = new Uint8Array(iv.length+cipherDataBuf.length);\n    allBuf.set(iv);\n    allBuf.set(cipherDataBuf, iv.length);\n    return toHex(allBuf);\n}\n\nexport async function decryptWithAes256Gcm(key, encryptedData) {\n    const importedKey = await importKeyAES256(key);\n\n    const iv = fromHex(encryptedData.slice(0,24));\n    const alg = {\n        name: \"AES-GCM\",\n        iv: iv,\n    };\n\n    return await crypto.subtle.decrypt(\n        alg, \n        importedKey, \n        fromHex(encryptedData.slice(24, encryptedData.length)),\n    );\n}\n","import { DIGEST, toHex } from './utils';\n\nasync function digest(alg, data) {\n    const hash = await crypto.subtle.digest(alg, data);\n    return new Uint8Array(hash);\n}\n\nexport async function sha1DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-1'], data);\n    return toHex(buf);\n}\n\nexport async function sha256DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-256'], data);\n    return toHex(buf);\n}\n\nexport async function sha384DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-384'], data);\n    return toHex(buf);\n}\n\nexport async function sha512DigestHex(data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await digest(DIGEST['SHA-512'], data);\n    return toHex(buf);\n}","import { DIGEST, toHex } from './utils';\n\nconst HMAC_MIN_KEY_SIZE = 32;\n\nasync function importKey(rawKey, hashAlg) {\n    if (rawKey.length < HMAC_MIN_KEY_SIZE) {\n        throw new Error(`min key length must be ${HMAC_MIN_KEY_SIZE} bytes length`);\n    }\n\n    const encoder = new TextEncoder();\n    return await crypto.subtle.importKey(\n        \"raw\", \n        encoder.encode(rawKey), \n        {\n            name: \"HMAC\", \n            hash: hashAlg,\n        }, \n        false, \n        ['sign', 'verify'],\n    );\n}\n\nasync function mac(key, hashAlg, data) {\n    const importedKey = await importKey(key, hashAlg);\n\n    const signature = await crypto.subtle.sign('HMAC', importedKey, data);\n    return new Uint8Array(signature);\n}\n\nexport async function sha1HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-1'], data);\n    return toHex(buf);\n}\n\nexport async function sha256HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-256'], data);\n    return toHex(buf);\n}\n\nexport async function sha384HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-384'], data);\n    return toHex(buf);\n}\n\nexport async function sha512HmacHex(key, data) {\n    if (typeof data == 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(data);\n    }\n\n    const buf = await mac(key, DIGEST['SHA-512'], data);\n    return toHex(buf);\n}","import { fromHex, toHex, str2ab, DIGEST, DIGEST_SALT_LENGTH } from './utils';\n\nfunction loadPublicKey(pem) {\n    const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n    const pemFooter = \"-----END PUBLIC KEY-----\\n\";\n    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);\n    // base64 decode the string to get the binary data\n    const binaryDerString = window.atob(pemContents);\n    // convert from a binary string to an ArrayBuffer\n    const binaryDer = str2ab(binaryDerString);\n    return binaryDer;\n}\n\nfunction loadPrivateKey(pem) {\n    // fetch the part of the PEM string between header and footer\n    const pemHeader = \"-----BEGIN PRIVATE KEY-----\";\n    const pemFooter = \"-----END PRIVATE KEY-----\\n\";\n    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);\n    // base64 decode the string to get the binary data\n    const binaryDerString = window.atob(pemContents);\n    // convert from a binary string to an ArrayBuffer\n    const binaryDer = str2ab(binaryDerString);\n    return binaryDer;\n}\n\nasync function loadPublicKeyForEncryption(pem, alg) {\n    const binaryDer = loadPublicKey(pem);\n\n    return await crypto.subtle.importKey(\n        'spki', \n        binaryDer, \n        {\n            name: 'RSA-OAEP',\n            hash: alg,\n        }, \n        true, \n        ['encrypt']\n    );\n}\n\nasync function loadPublicKeyForVerifySignature(pem, alg) {\n    const binaryDer = loadPublicKey(pem);\n\n    return await crypto.subtle.importKey(\n        'spki', \n        binaryDer, \n        {\n            name: 'RSA-PSS',\n            hash: alg,\n        }, \n        true, \n        ['verify']\n    );\n}\n\n//  format should be PKCS8\nasync function loadPrivateKeyForEncryption(pem, alg) {\n    const binaryDer = loadPrivateKey(pem)\n\n    return await window.crypto.subtle.importKey(\n        'pkcs8',\n        binaryDer,\n        {\n            name: 'RSA-OAEP',\n            hash: alg,\n        },\n        true,\n        ['decrypt']  \n    );\n}\n\n//  format should be PKCS8\nasync function loadPrivateKeyForSigning(pem, alg) {\n    const binaryDer = loadPrivateKey(pem)\n\n    return await window.crypto.subtle.importKey(\n        'pkcs8',\n        binaryDer,\n        {\n            name: 'RSA-PSS',\n            hash: alg,\n        },\n        true,\n        ['sign']  \n    );\n}\n\nasync function encryptWithOAEP(publicKey, hash, plainData) {\n    const key = await loadPublicKeyForEncryption(publicKey, hash);\n    return await window.crypto.subtle.encrypt(\n        {\n            name: 'RSA-OAEP',\n            hash: hash,\n        },\n        key,\n        plainData,\n    );\n}\n\nasync function decryptWithOAEP(privateKey, hash, encryptedData) {\n    const key = await loadPrivateKeyForEncryption(privateKey, hash);\n    return await window.crypto.subtle.decrypt(\n        {\n            name: 'RSA-OAEP',\n            hash: hash,\n        },\n        key,\n        encryptedData,\n    );\n}\n\n// encryption\nexport function encryptWithOAEPSha1(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-1'], plainData);\n}\n\nexport function encryptWithOAEPSha256(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-256'], plainData);\n}\n\nexport function encryptWithOAEPSha384(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-384'], plainData);\n}\n\nexport function encryptWithOAEPSha512(publicKey, plainData) {\n    return encryptWithOAEP(publicKey, DIGEST['SHA-512'], plainData);\n}\n\n// decryption\nexport function decryptWithOAEPSha1(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-1'], encryptedData);\n}\n\nexport function decryptWithOAEPSha256(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-256'], encryptedData);\n}\n\nexport function decryptWithOAEPSha384(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-384'], encryptedData);\n}\n\nexport function decryptWithOAEPSha512(privateKey, encryptedData) {\n    return decryptWithOAEP(privateKey, DIGEST['SHA-512'], encryptedData);\n}\n\n// digital signature\n\n// sign data with PSS and return a promise a promise that fulfills an array buffer containing the signature\nasync function signWithPss(privateKey, hash, data) {\n    const key = await loadPrivateKeyForSigning(privateKey, hash);\n    return await window.crypto.subtle.sign(\n        {\n            name: 'RSA-PSS',\n            saltLength: DIGEST_SALT_LENGTH[hash]\n        },\n        key,\n        data,\n    );\n}\n\n// verify signature with PSS and return a Promise that fulfills with a boolean value: true if the signature is valid, false otherwise.\nasync function verifySignatureWithPss(publicKey, signature, hash, data) {\n    const key = await loadPublicKeyForVerifySignature(publicKey, hash);\n    return await window.crypto.subtle.verify(\n        {\n            name: 'RSA-PSS',\n            saltLength: DIGEST_SALT_LENGTH[hash]\n        },\n        key,\n        signature,\n        data,\n    );\n}\n\nexport function signWithPssSha1(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-1'], data);\n}\n\nexport function signWithPssSha256(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-256'], data);\n}\n\nexport function signWithPssSha384(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-384'], data);\n}\n\nexport function signWithPssSha512(privateKey, data) {\n    return signWithPss(privateKey, DIGEST['SHA-512'], data);\n}\n\nexport function verifySignatureWithPssSha1(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-1'], data);\n}\n\nexport function verifySignatureWithPssSha256(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-256'], data);\n}\n\nexport function verifySignatureWithPssSha384(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-384'], data);\n}\n\nexport function verifySignatureWithPssSha512(publicKey, signature, data) {\n    return verifySignatureWithPss(publicKey, signature, DIGEST['SHA-512'], data);\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","HEX_STRINGS","MAP_HEX","a","b","c","d","e","f","A","B","C","D","E","F","toHex","bytes","Array","from","map","join","fromHex","hexString","Uint8Array","Math","floor","length","i","undefined","slice","str2ab","str","buf","ArrayBuffer","bufView","strLen","charCodeAt","stringToArrayBuffer","data","decodeURIComponent","encodeURIComponent","arrayBuf","arrayBufferToString","arrayBuffer","byteArray","byteLength","String","fromCharCode","DIGEST","DIGEST_SALT_LENGTH","async","importKeyAES256","rawKey","Error","encoder","TextEncoder","crypto","subtle","importKey","encode","name","encryptWithAes256Gcm","importedKey","encoded","iv","getRandomValues","alg","cipherData","encrypt","cipherDataBuf","allBuf","set","decryptWithAes256Gcm","encryptedData","decrypt","digest","hash","sha1DigestHex","sha256DigestHex","sha384DigestHex","sha512DigestHex","mac","hashAlg","signature","sign","sha1HmacHex","sha256HmacHex","sha384HmacHex","sha512HmacHex","loadPublicKey","pem","pemContents","substring","window","atob","loadPrivateKey","encryptWithOAEP","publicKey","plainData","binaryDer","loadPublicKeyForEncryption","decryptWithOAEP","privateKey","loadPrivateKeyForEncryption","encryptWithOAEPSha1","encryptWithOAEPSha256","encryptWithOAEPSha384","encryptWithOAEPSha512","decryptWithOAEPSha1","decryptWithOAEPSha256","decryptWithOAEPSha384","decryptWithOAEPSha512","signWithPss","loadPrivateKeyForSigning","saltLength","verifySignatureWithPss","loadPublicKeyForVerifySignature","verify","signWithPssSha1","signWithPssSha256","signWithPssSha384","signWithPssSha512","verifySignatureWithPssSha1","verifySignatureWithPssSha256","verifySignatureWithPssSha384","verifySignatureWithPssSha512"],"sourceRoot":""}